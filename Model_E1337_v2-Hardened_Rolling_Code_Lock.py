# Importing Packages #
from requests import get as get_request, post as post_request
from re import search as search_flag, findall as find_all_flags
# Getting CTF URL #
ctf_url = f"https://{input("\033[32m[1] Enter your ctf id: \033[0m")}.ctf.hacker101.com"
# Declaring Flags list #
FLAGS = []

# Class to solve #
class RNGState:
    def __init__(self, rng_res):
        # Initialize the RNG state, equations, and other necessary variables
        self.RESERVED = {64}  # Reserved bit index, as given in the original code
        self.state_a = self.initialise_state_a()  # Initialize the state (64-bit)
        self.rng_res = rng_res  # RNG result from server
        self.NBIT = 64  # Number of bits in each number (default: 64)
        self.NNUMBER = len(rng_res)  # Number of RNG numbers
        self.ret_b = [int(i) for i in "".join(['0'*(self.NBIT-len(bin(i)[2:])) + bin(i)[2:] for i in rng_res])]  # Binary representation of rng_res
        self.all_ret = []  # Store all random bits generated by the RNG
        self.eqns = []  # List to store equations generated from RNG results
        self.eqns_rhs = []  # Right-hand side values for the equations

        # Initialize state and generate the initial set of equations
        self.generate_equations()

    def initialise_state_a(self):
        # Initializes the state `state_a` as a list of sets, where each set represents a 64-bit state with an index.
       
        return [{63-i} for i in range(64)]  # State initialization: list of sets representing bit positions

    def getrandbit_track2(self):
        # Simulates the RNG's bit generation process, updating the state and returning the next random bit.
        ret = self.state_a[-1]  # Get the last element of the current state

        for k in range(3):  # Perform 3 rounds of state transformation
            new = [None] * 64  # Create a new list to store the updated state
            for i in range(61):
                new[i] = self.state_a[i + 1]  # Shift the state to the right by one position
            new[61] = self.state_a[62] ^ self.state_a[0]  # XOR the 62nd and 0th bit
            new[62] = self.state_a[63] ^ self.state_a[1]  # XOR the 63rd and 1st bit
            new[63] = self.state_a[2]  # Set the 64th bit to the 3rd bit from the original state
            self.state_a = new[:]  # Update the state

            # XOR all bits in state with the RESERVED bit index
            self.state_a = [i ^ self.RESERVED for i in self.state_a]

            # Update the state based on XORing groups of 4 bits
            for j in range(0, 64, 4):
                if j == 0:
                    cur = self.state_a[-j-4:]  # Extract the last 4 bits
                else:
                    cur = self.state_a[-j-4:-j]  # Extract a group of 4 bits
                cur_ = [cur[-1], cur[-1], cur[-4], cur[-4]]  # Duplicate and prepare the group
                i = 0
                for k in range(60-j, 64-j):  # XOR the current state with the group
                    self.state_a[k] = self.state_a[k] ^ cur_[i]
                    i += 1
        return self.state_a, ret  # Return the updated state and the generated bit

    def solve_xor(self, eqns):
        # Solves a system of XOR equations using Gaussian Elimination. The equations are in the form of bit index sets with corresponding binary results (0 or 1).
        res = list(self.RESERVED)[0]
        for idx, eqn in enumerate(eqns):
            if res in eqn[0]:  # If RESERVED bit is part of the equation, adjust it
                eqn[0] = eqn[0] ^ self.RESERVED
                eqn[1] = eqn[1] ^ 1
                eqns[idx] = eqn

        used = []  # Track used equations during the elimination process
        for bit in range(64):  # Process each bit in the equations
            cut_short = False
            eqn_idx = 0
            while eqn_idx < len(eqns):  # Find the first equation with the current bit
                eqn = eqns[eqn_idx]
                if bit not in eqn[0]:
                    eqn_idx += 1
                    continue
                elif eqn_idx in used:
                    eqn_idx += 1
                    continue
                else:
                    first_idx = eqn_idx
                    eqn_idx += 1
                    break
                if eqn_idx == len(eqns) - 1:
                    cut_short = True
            if cut_short: continue

            used.append(first_idx)  # Mark the equation as used

            eqn_idx = 0
            while eqn_idx < len(eqns):  # Eliminate the current bit from the other equations
                eqn = eqns[eqn_idx]
                if first_idx == eqn_idx:
                    eqn_idx += 1
                    continue
                if bit in eqn[0]:
                    mod_eqn = eqns[first_idx][0] ^ eqn[0]
                    mod_bit = eqns[first_idx][1] ^ eqn[1]
                    eqns[eqn_idx] = [mod_eqn, mod_bit]
                eqn_idx += 1

        # Check for any inconsistent equations
        for eqn in eqns:
            if len(eqn[0]) == 0 and eqn[1] == 1:
                print("[WARNING] System of equations make no sense")

        # Remove empty equations
        eqns = [i for i in eqns if len(i[0]) != 0]

        return eqns

    def decompose_eqn(self, eqns_, eqn_to_decompose):
        # Attempts to decompose the given equation into a combination of the other equations using XOR.

        A = eqn_to_decompose
        contains_res = self.RESERVED in A  # Check if the RESERVED bit is in the equation
        
        eqns = eqns_ + [[A]]  # Add the equation to the list for processing
        
        used = []  # Track used equations during decomposition
        bits_A = list(A)  # Break down the equation into individual bits

        composition = []  # Store the list of equations that can be XORed to produce the desired equation
        for bit in range(64):  # Process each bit in the equation
            cut_short = False
            eqn_idx = 0

            while eqn_idx < len(eqns)-1:  # Find the first equation containing the current bit
                eqn = eqns[eqn_idx]
                if bit not in eqn[0]:
                    eqn_idx += 1
                    continue
                elif eqn_idx in used:
                    eqn_idx += 1
                    continue
                else:
                    first_idx = eqn_idx
                    break
                if eqn_idx == len(eqns) - 2:
                    cut_short = True

            if cut_short: continue
            used.append(first_idx)

            # Gaussian eliminate only the last row (eqn_to_decompose)
            if bit in eqns[-1][0]:
                mod_eqn = eqns[first_idx][0] ^ eqns[-1][0]
                eqns[-1] = [mod_eqn, None]
                composition.append(first_idx)

        # Check if the equation can be composed from others
        if len(eqns[-1][0]) != 0: 
            print("[WARNING] Equation cannot be composed from given eqns")
        return composition

    def generate_equations(self):
        # Generates the system of XOR equations from the given RNG results. The equations are stored in `self.eqns`, and their right-hand side (result) in `self.eqns_rhs`.
        state_a = self.state_a
        for i in range(self.NBIT * self.NNUMBER):  # Generate NBIT * NNUMBER random bits
            state_a, ret = self.getrandbit_track2()  # Generate the next random bit
            self.all_ret.append(ret)

        # Form equations by pairing generated random bits with the server's bits
        self.eqns = [[x, y] for x, y in zip(self.all_ret, self.ret_b)]
        self.eqns = self.solve_xor(self.eqns)  # Solve the system of XOR equations
        self.eqns_rhs = [eq[1] for eq in self.eqns]  # Store the right-hand side of the equations

    def predict_next_number(self):
        # Predicts the next number in the sequence by decomposing the equations and XORing the results together.
        pred_eqns = []
        for i in range(self.NBIT):  # Generate predictions for each bit
            state_a, ret = self.getrandbit_track2()  # Get the next random bit
            pred_eqns.append(ret)

        bits = ""
        for pred_eqn in pred_eqns:
            # Decompose each predicted equation using the known equations
            composition = self.decompose_eqn(self.eqns, pred_eqn)
            pred = self.eqns_rhs[composition[0]]  # Start with the first equation in the composition
            for idx in composition[1:]:  # XOR all the equations together
                pred = pred ^ self.eqns_rhs[idx]
            bits = bits + str(pred)  # Construct the bit string

        # Convert the bit string to an integer
        return int(bits, 2)

# Handling Exceptions #
try:
    # Checking for correct ctf id #
    if get_request(ctf_url).status_code == 200:
        # Printing Message before featching all flags #
        print("\033[33m[2] Please wait while we featch all flags.\033[0m")
        # Predicting next number #
        rng_res = post_request(f"{ctf_url}/unlock", data={"code": 12172402}).text.replace("Code incorrect.  Expected ", "")
        rng_state = RNGState([int(rng_res)])
        FLAGS.append(f'^FLAG^{search_flag(r"\^FLAG\^(.*?)\$FLAG\$", post_request(f"{ctf_url}/unlock", data={"code": rng_state.predict_next_number()}).text).group(1)}$FLAG$')
    else:
        print("\033[33m[2] Wrong ctf id check and try again.\033[0m")
except Exception as e:
    # Printing Exception #
    print(f"\033[31m[3] {str(e)}\033[0m")
# Printing all the flags #
print(f"\033[32m[3] Your flags are: {FLAGS}\033[0m")